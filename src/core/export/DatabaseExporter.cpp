#include "DatabaseExporter.h"

#include <filesystem>
#include <fstream>
#include <iostream>

bool DatabaseExporter::exportToSQL(DatabaseManager* dbManager, TableManager* tableManager, const std::string& filename)
{
    try
    {
        std::string dbName = std::filesystem::path(filename).stem().string();
        DatabaseStructureHandler structureHandler(dbManager, tableManager);

        return writeToFile(filename, dbName, structureHandler);
    }
    catch (const std::exception& e)
    {
        std::cerr << "Export error: " << e.what() << std::endl;
        return false;
    }
}

bool DatabaseExporter::importFromSQL(DatabaseManager* dbManager, const std::string& filename)
{
    try
    {
        std::ifstream file(filename);

        if (!file.is_open())
            throw std::runtime_error("Cannot open file: " + filename);

        std::stringstream buffer;
        buffer << file.rdbuf();
        std::string sql = buffer.str();

        auto statements = SQLScriptParser::parseScript(sql);
        return executeStatements(dbManager, statements);
    }
    catch (const std::exception& e)
    {
        std::cerr << "Import error: " << e.what() << std::endl;
        return false;
    }
}

bool DatabaseExporter::writeToFile(const std::string& filename, const std::string& dbName, DatabaseStructureHandler& structureHandler)
{
    std::filesystem::create_directories("exports");
    std::ofstream file(filename);

    if (!file.is_open())
        return false;

    file << generateHeader(dbName);

    auto tables = structureHandler.getOrderedTableNames();

    for (const auto& table : tables)
        file << structureHandler.getCreateStatement(table) << ";\n\n";

    for (const auto& table : tables)
    {
        auto insertStatements = structureHandler.getInsertStatements(table);
        if (!insertStatements.empty())
        {
            file << "-- Dumping data for table `" << table << "`\n";

            for (const auto& stmt : insertStatements)
                file << stmt << ";\n";

            file << "\n";
        }
    }

    return true;
}

bool DatabaseExporter::executeStatements(DatabaseManager* dbManager, const std::vector<SQLScriptParser::SQLStatement>& statements)
{
    try
    {
        auto& session = dbManager->getSession();

        for (const auto& stmt : statements)
        {
            if (stmt.type != SQLScriptParser::SQLStatement::Type::CREATE_TABLE &&
                stmt.type != SQLScriptParser::SQLStatement::Type::INSERT)
            {
                std::cout << "Executing: " << stmt.content << std::endl;
                session.sql(stmt.content).execute();
            }
        }

        for (const auto& stmt : statements)
        {
            if (stmt.type == SQLScriptParser::SQLStatement::Type::CREATE_TABLE)
            {
                std::cout << "Creating table: " << stmt.tableName << std::endl;
                session.sql(stmt.content).execute();
            }
        }

        for (const auto& stmt : statements)
        {
            if (stmt.type == SQLScriptParser::SQLStatement::Type::INSERT)
                session.sql(stmt.content).execute();
        }

        return true;
    }
    catch (const mysqlx::Error& e)
    {
        std::cerr << "MySQL error during statement execution: " << e.what() << std::endl;
        throw;
    }
}

std::string DatabaseExporter::generateHeader(const std::string& dbName)
{
    std::stringstream ss;
    ss << "-- Database export\n";
    ss << "-- Generated by BodyaSQL\n";
    ss << "-- Database: " << dbName << "\n\n";
    ss << "SET FOREIGN_KEY_CHECKS=0;\n\n";
    ss << "CREATE DATABASE IF NOT EXISTS `" << dbName << "`;\n";
    ss << "USE `" << dbName << "`;\n\n";
    return ss.str();
}
